#!/usr/bin/perl
#
#  drib
# =================================
#  (c) Copyright Travis Kuhl 2009
#  
#

# our package
package drib;

# version
my $VERSION = "0.0.4";

# use packages
use Getopt::Long;
use Data::Dumper;
use JSON;
use File::Basename;
use POSIX;
use Digest::MD5 qw(md5_hex);

# where our var folder is
use constant VAR => "./";
use constant LIB => "./lib";

# load our config
use lib LIB;

# drib packages
use dist::local;
use dist::remote;
use utils;
use external;
use db;

# act 
my $act = 'help';

# need at least one argv
if ( $#ARGV != -1 ) {

    # act 
    $act = $ARGV[0];
    
}

# aliases
my %Alias = ('ls'=>'list','h'=>'help','i'=>'install','c'=>'create');

# what are the avail commands
my $Commands = {
	
    # help
	'help' => {
	   'func' => \&help,
	   'help' => 'Show this message',
	   'opts' => {
	       'version' => 'version|v'
	   }
    },
    
    # self-install
	'self-install' => {
        'func' => \&self_install,
        'help' => "Install the downloaded version of drib",
	   'opts' => {
            'type'=>'type|t=s',
	   }        
    },
    
    # self-update
    'self-update' => {
        'func' => \&self_update,
        'help' => "Update drib to the given version",
        'opts' => {
            'version'=>'version=s',
            'branch'=>'branch=s'
        }
    },
    
    # install
	'install' => {
        'func' => \&install,
        'help' => "Install a package from dist",
        'opts' => {
            'cleanup'=>'cleanup|c',        
            'project'=>'project|p=s',
            'version'=>'version=s',
            'branch'=>'branch=s'
        }
    },
    
    # create
	'create' => {
        'func' => \&create,
        'help' => "Create a package",
        'opts' => {
            'project'=>'project|p=s',
            'branch'=>'branch|b=s',
            'install'=>'install|i',
            'type'=>'type|t=s',
            'dist'=>'dist!',
            'cleanup'=>'cleanup|c'                    
        }        
    },
    
    # set 
    'set' => {
        'func' => \&set,
        'help' => "Set package variables",
        'opts' => {}
    },
    
    # list installed packages
    'list' => {
        'func' => \&list,
        'help' => "List all installed packages",
        'opts' => {
            'project' => 'project|p=s'
        }
    }
	
};

my $CONFIG = 0;
my $DIST = 0;
my $PACKAGES = 0;
my $SETTINGS = 0;

# if we self-install, we don't need
# dist or config, mostly because it doesn't 
# really exist
unless ( $act eq 'self-install' ) {
	
	# set some thigns
    $CONFIG = new drib::db('config',VAR);	
    $DIST = new drib::dist::remote($CONFIG);
    $PACKAGES = new drib::db('packges',VAR);
	$SETTINGS = new drib::db('settings',VAR);
    	
    # if not running as root
    if ( $> != 0 ) {
        my $cmd = "sudo $0 ".join(" ",@ARGV); print `$cmd`; exit;
    }	

    # define what happens when we end
    END {
        $CONFIG->save() if $CONFIG;
        $PACKAGES->save() if $PACKAGES;
        $SETTINGS->save() if $SETTINGS;
    }
	
}


# cmds 
my @cmds = @ARGV; shift @cmds;

# check for a map 
if ( exists $Alias{$act} ) {
    $act = $Alias{$act};
}

# is the given command correct
unless ( exists $Commands->{$act} ) {
    $act = 'help';
}

# get options
my %options = ();

    # opts
    my $opts = $Commands->{$act}->{opts};
    
    # get options
    GetOptions(\%options, values %{$opts});    

# call it 
$Commands->{$act}->{func}();

# done
exit 1;

# help
sub help {

    # check if we want to show the version
    if ( $options{'version'} ) {
    
        # fail with version
        fail("drib $VERSION\nCopyright (C) Travis Kuhl 2009-10\n\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\nThere is NO WARRANTY, to the extent permitted by law.");
    
    }
    elsif ( $#cmds != -1 ) {
    
        # my
        my $c = $cmds[0];
        my $opts = ();
    
        # is it a valid command
        unless ( exists $Commands->{$c} ) {
            fail("Invalid Command.");
        }
        
        # if options
        foreach my $o ( keys %{$Commands->{$c}->{opts}} ) {
            if ( index($Commands->{$c}->{opts}->{$o},'=') != -1 ) {
                push(@opts,"--$o=[$o]");
            }
            else {            
                push(@opts,"--$o");
            }
        }
    
        # print out the usage
        msg("usage: drib [options] $c " . join(' ',@opts));
        msg($Commands->{$c}->{help});
    
    }
    else {
    
        # usage
        msg("usage: drib [options] command [sub-command] [command-options]\n\nList of Commands:");
        
        # show them commands
        foreach my $key ( keys %{$Commands} ) {
            printf(" %-20s %s\n", "$key","$Commands->{$key}->{help}");
        }
        
        # nothing more to do
        exit;
        
    }

}

# self_install
sub self_install {

	# what we need
	my ($conf,$var);

    # if not running as root
    if ( $> != 0 ) {
        fail("You must install as root.");
    }	
    
    # shift off install
    shift @ARGV;

	# ask
	my @Ask = (
	    ['username',"What is your drib.it Username",""],
		['key', "What is your drib.it API Key",""],
		['secret',"What is your drib.it API Secret",""],
		['project',"What would you like your default project to be?","default"],
		['binf',"Bin directory","/usr/local/bin"],
		['libf',"Lib directory","/usr/local/lib"],
		['varf',"Var directory","/usr/local/var"],
		['tmpf',"Tmp directory","/tmp"]
	);

	# ask them some questions
	foreach my $a ( @Ask ) {
		
		# back to an array
		@v = @{$a};
		
		if ( $#v == 2 ) {
			print $v[1]." [".$v[2]."]: "; 
		}
		else {
			print $v[1].": ";
		}
		$var = <>;
		chomp $var;
		if ( $var eq "" ) {
			$var = $v[2];
		}
		$conf->{$v[0]} = $var;
	}  	
	
	# need them
    if ( $conf->{'username'} eq "" || $conf->{'key'} eq "" || $conf->{'secret'} eq "" ) {
        fail("You didn't enter a Username, API Key or Secret. You need to do that before we can install.");
	}
	
    # personalize the package file
    my $pkgfile = file_get("../pkg/drib.pkg");	

	# replace our lib 
	$pkgfile =~ s/\$bin = ""/\$bin = "$conf->{'binf'}"/;
	$pkgfile =~ s/\$lib = ""/\$lib = "$conf->{'libf'}"/;
	$pkgfile =~ s/\$var = ""/\$var = "$conf->{'varf'}"/;
	$pkgfile =~ s/\$tmp = ""/\$tmp = "$conf->{'tmpf'}"/;		

    # now rewrite package
    file_put("../pkg/drib.pkg.tmp",$pkgfile);

    # open our file
    my $file = file_get("./drib");
    
	# replace our lib 
	$file =~ s/VAR =\> "\.\/"/VAR => "$conf->{'varf'}\/drib"/;
	$file =~ s/LIB =\> "\.\/lib"/LIB => "$conf->{'libf'}\/drib"/;

	# put the content back
	file_put("./drib",$file);	

    # files
    $conf->{'libf'} .= "/drib";
    $conf->{'varf'} .= "/drib";
    $conf->{'tmpf'} .= "/drib";

	# need var dir now
	mkdir $conf->{'varf'};

	# save our json conf
	my $json = to_json({'default'=>$conf});
	
	# create our conf file
	file_put($conf->{'varf'}."/config.json",$json);

    # where are we 
    my $pwd = getcwd();
    
    # conifg
    $CONFIG = new drib::db('config',$conf->{'varf'});
    $PACKAGES = new drib::db('packges',VAR);
	$SETTINGS = new drib::db('settings',VAR);    
    
    # set our options
    $options{'dist'} = 0;
    $options{'install'} = 1;
    $options{'cleanup'} = 1;
    
    # run create
    &create("$pwd/../pkg/drib.pkg.tmp");

    # remove some stuff
    `rm ../pkg/drib.pkg.tmp`;
    
}


# install
sub install {
	
	# given a file
	my ($pkg_file) = @_;
	
	# get commands
	my ($pkg,$version,$file,$project);

	# need a package name
	if ( $#cmds == -1 && !$pkg_file ) { fail("No Package Given"); }
	
	# if package has .tar.gz
	# we don't need to go to dist
	if ( $pkg_file || $cmds[0] =~ /\.tar\.gz/ ) {
     
        # not given
        if ( !$pkg_file ) {
            $pkg_file = $cmds[0];
        }
        
        # where
        unless ( -e "./$pkg_file" ) {
            fail("Package file $pkg_file does not exists");
        }
     
        # get it 
        $file = file_get($pkg_file);	
        
        # if cleanup
        if ( $options{'cleanup'} ) {
            `rm $pkg_file`;
        }
        
	}
	else {
	
        # try to split the package for a version
        my @pkg_info = split(/-/,$cmds[0]);
        
        # check name for a project name
        my @name_info = split(/\//,$pkg_info[0]);
        
        # project
        my $project = $options{'project'} || $CONFIG->get('project');        
        my $pkg = 0;

        # what up
        if ( $#name_info == 1 ) {
            $project = $name_info[0];
            $pkg = $name_info[1];
        }
        else {
            $pkg = $name_info[0];
        }
        
    	# get verison and branch
    	my $ver = $options{'version'};
    	my $branch = $options{'branch'} || 'current';
    	    		
    	# if they gave a verions
    	if ( $#pkg_info == 1 ) {
    		$version = $pkg_info[1];
    	}
    	elsif ( $ver ) { 
    		$version = $ver;
    	}
    	else {
    		$version = $branch;
    	}	
    	
        # check for external projects
        if ( in_array(\@external::PROJECTS,$project) ) {
        
            # what happeend
            $resp = &external::_map($project,$pkg,$version);
            
            # done
            exit;
            
        }    
    
    	# check if the package ist installed
    	my $installed = $PACKAGES->get($project,$pkg);
    
    		# if yes is it the same version
    		if ( $installed ne 0 ) {
    			fail("$pkg-$version is already installed");
    		}
    
    	# now we need to check with dist 
    	# to see if this package exists 
    	my $exists = $DIST->check($project,$pkg,$version);
    
    	# if it exists we need to error
    	if ( !$exists ) {
    		fail("Package $pkg-$version does not exist.");
    	}
    
    	# ok so we now have it 
    	# so lets get the file
    	$file = $DIST->get($project,$pkg,$version);
    	
    }

	# make a tmp dir
	my $tdir = $CONFIG->get('tmpf') . "/" . rand_str(10);
	
	# make it 
	`mkdir $tdir`;
	
	# save the file to tdir 
	file_put($tdir."/pkg",$file);
	
	# now move into the tmp dir 
	chdir $tdir;
	
	# untar the file
	`tar -xzf pkg`;
	
	# open our manifest
	my $manifest = from_json( file_get($tdir.'/.manifest') );
	
	# now lets get a list of all directories
	# and move them into place
	opendir(my $dh, '.');
	my @dirs = readdir($dh);
	close($dh);
	
	# loop and move each of the 
	# files to root. we force the 
	# move. so if any existing folders 
	foreach my $d ( @dirs ) {
		if ( $d ne '.' && $d ne '..' && -d $d ) {
			`cp -rf ./$d /`;
		}
	}

    # make a pid
    my $pid = md5_hex($manifest->{project}."-".$manifest->{meta}->{name});
    
    # don't need raw or changelog
    $manifest->{raw} = "";
    $manifest->{changelog} = "";
    
	# add package to our package db
	$PACKAGES->set($pid,$manifest);
    
    # set it 
    $PACKAGES->add($manifest->{meta}->{name},$pid,'map');

    # any settings
    $SETTINGS->set($pid,$manifest->{set});

    # cleanup our tmp dir
    `rm -r $tdir`;    
	
	# tell them we're done
	fail("Package $manifest->{meta}->{name} installed!");
	
}

sub create {

	# given a file
	my ($pkg_file) = @_;
	
	# file
	my $file = 0;
	
	# what up
	if ( $pkg_file ) {
	   $file = $pkg_file;
	}
	elsif ($#cmds != -1) {
	   $file = $cmds[0];
	}
	else {
	   fail("No Build Manifest given");
	}

	# optns
	my $dist = $options{'dist'};
	my $branch = $options{'branch'} || 'current';
	my $type = $options{'type'} || 'release';
	my $install = $options{'install'} || 0;

        # not defined
        unless ( defined $options{'dist'} ) {
            $dist = 1;
        }
	
	# make sure we're in the correct folder
    my ($fname,$fpath) = fileparse($file);	
	
	# where are we now
	my $pwd = getcwd();    
    
    # move into fpath
    chdir $fpath;

	# open the manifest
	my $man = file_get($file);

	# check if the first two chars are 
	# a hash bang
	if ( substr($man,0,2) eq "#!" ) {
		$man = `$file`;
	}

	# save the man as a tmp file
	my $tmp = $CONFIG->get('tmpf') . "/" . rand_str(5);

	# put the man
	file_put($tmp,$man);
	
	# what we need 
	our $Meta = 0;
	our $Set = 0;
	our $Dirs = 0;
	our $Files = 0;
	our $Commands = 0;
	our $Apache = 0;
	
	# try to include the file
	eval {
		do "$tmp";
	};
	
	# don't need the file anymore
	unlink $tmp;
	
	# if we couldn't we need to fail
	if ($@) {
		fail("Could not parse the Build Manifest");
	}	
		
	# make sure we have what we need
 	if ( $Meta == 0) {
 		fail("Meta variable not defined in Build Manifest");
 	}

	# we need the package name
	my $pkg = $Meta->{name};
	my $version = $Meta->{version};
	my $project = $options{project} || $CONFIG->get('project');
	
	   # is project defined in meta
	   if ( exists $Meta->{project} ) {
	       $project = $Meta->{project};
	   }
	   
    # version
    if ( $type eq "symlink" || $type eq "s" ) {
        $version = "$version.S".time();
    }
    elsif ( $type eq "test" || $type eq "t" ) {
        $version = "$version.T".time();
    }

	# unless config tells us no dist we want
	# to make sure this version doesn't already 
	# exist
	if ( $dist == 1 ) {
		if ( $DIST->check($project,$pkg,$version) ) {
			fail("Package '$pkg' version '$version' already exists");
		}
	}

	# need the changelog
	unless ( -e $Meta->{changelog} ) {
		fail("Changelog file ($Meta->{changelog}) does not exist.");
	}

	# now we need to create a tmp director
	my $tdir_name = rand_str(10);
	my $tdir = $CONFIG->get('tmpf') . "/" . $tdir_name;

	# create the dir
	`mkdir $tdir`;
	
	# listsings of what we've created
	my @listing = ();

	# now create and dirs they want
	if ( $Dirs != 0 ) {
		foreach my $dir ( @{$Dirs} ) {
			my $d = $tdir . "/" . trim($dir,1);
			`sudo mkdir -p $d`;
			push(@listing,$d);
		}
	}
	
	# no files
	if ( $Files != 0 ) {
		foreach my $f ( @{$Files} ) {
			
			# where are we going
			my $d = $tdir . trim($f->[0]);
			
			# if the dest doesn't exist 
			# we need to create it 
			unless ( -e $d ) {				
				`sudo mkdir -p $d`;			
			}
			
			# all the files
			my @files = ();
			
			# now figure out if src is a
			# single file or a ref
			unless ( ref($f->[1]) eq "HASH" ) {
				$f->[1] = {'src'=>$f->[1]};
			}
			
			# files
			my $file = $f->[1];
			
			# check if we have one file or many
			if ( defined $file->{src} ) {
				
				# add it
				push(@files,$file);
								
			}
			else {
			
				# check for lfind
				if ( defined $file->{find} ) {
					
					# run the find
					my $r = `sudo find $file->{find}`;
					my $root = "";
					
					# root 
					if ( defined $file->{root} ) {
					   $root = trim($file->{root});
					}
										
					# each file
					foreach my $item ( split(/\n/,$r) ) {
					   
                        # parse the file path
                        my ($fname,$fpath) = fileparse($item);
                        
                        # append
                        $append = "";
                        
                        # if path does not eq root
                        # we need to append the subdir to the 
                        # final dest also
                        if ( $root ne "" && trim($fpath) ne $root ) {
                            $fpath =~ s/$root//;
                            $append = $fpath;
                        }
					
                        # push ontop
						push(@files,{'src'=>$item,'user'=>$file->{user},'group'=>$file->{group},'mode'=>$file->{mode},'append'=>$append});
						
					}
					
				}					
			
			}
			
			
			# loop through each file
			foreach my $item ( @files ) {
		
				# filename
				my $n = basename($item->{src});
		
				# dest
				my $_d = "$d/$n";
				
				# check for append
				if ( defined $item->{append} && $item->{append} ne "" ) {
				
				    # append
				    $_d = "$d$item->{append}";
				    
				    # directory may not exist. we need to create it
				    unless ( -d $_d ) {
				        `mkdir -p $_d`;
				    }
				    
				    # append name
				    $_d .= $n;
				    
				}
				
				# push
				push(@listing,$_d);
	
                # now see what type of build we have
                if ( $type eq 'symlink' || $type eq 's' ) {
                    my $_s = $pwd . "/" . $item->{src};
                    symlink $_s, $_d;
                }
                else {	
    				`cp $item->{src} $_d`;
                }
			
				# if user
				if ( defined $item->{user} ) {
					`chown $item->{user} $_d`;
				}
				
				# group
				if ( defined $item->{group} ) {
					`chown :$item->{group} $_d`;
				}
				
				# mode
				if ( defined $item->{mode} ) {
					`chmod $item->{mode} $_d`;
				}				
		
		        # rename
		        if ( defined $item->{rename} ) {
                    `mv $_d $d/$item->{rename}`;
		        }
		  
			}
							
		}
	} # END @files	
	
	# nice list of files
	my @nicelist = map { s/$tdir//g; $_; } @listing;
	
	# need to create our own version of the manifest
	my $manifest = {
	    'project' => $project,
		'type' => $type,	
		'meta' => $Meta,
		'set' => $Set,
		'commands' => $Commands,
		'apache' => $Apache,
		'raw' => $man,
		'changelog' => file_get($Meta->{changelog}),
		'buildenv' => {
			'user' => $ENV{'USER'},
			'host' => $ENV{'HOSTNAME'},
			'pwd' => $ENV{'PWD'}			
		},
		'files' => \@nicelist
	};
	
	# add our manifest to the build 
	file_put($tdir."/.manifest", to_json($manifest) );

	# move to our folder
	chdir $tdir;
	
	# name 
	my $name = "$pkg-$version";

	# tar 
	`tar -czf $name.tar.gz .`;
	
	# package
	my $package = "$tdir/$pkg-$version.tar.gz";

	# now send our file to dist
	if ( $type eq 'release' && $dist == 1 ) {
    	$DIST->upload({
    	   'project' => $project,
    	   'username' => $CONFIG->get('username'),
    	   'name' => $pkg,
    	   'version' => $version,
    	   'branch' => $branch,
    	   'tar' => file_get($package)
        });
    }
    
    # or move the file back to the pwd 
    else {
    
        # put package in this directory
        `mv $package $pwd`;
    
    }
    
    # move back to current
    chdir $pwd;

	# remove our tmp dir
	`rm -r $tdir`;	

    # install
    if ( $install ) {
    
        # msg
        msg("Package Created: $name");
     
        # run install
        &install($name.".tar.gz");
        
    }
    else {

    	# done
    	fail("Package Created: $name");
    	
    }

    # set env vars
    sub set {

        # packages
    	my $packages = $PACKAGES->all();    

    	# no subcommand we assume to show all packages
    	if ( $#cmds == -1 ) { 
    	
            # get all settings
            my $settings = $SETTINGS->all();
    	
            # print them
            foreach my $pid ( keys %{$packages} ) {
                
                # settings
                my $s = $settings->{$pid};
                
                # loop and show
                foreach my $key ( keys %{$s} ) {
                    msg(" $packages->{$pid}->{meta}->{name}.$key: $s->{$key} ");
                }
                
            }
    	
            # done
            exit();
    	
        }
    	
    	# map
    	my @map = @{$PACKAGES->get($cmds[0],'map')};
    	
    	# package
    	my $package = 0;
    	my $pid = 0;
    	
        # how many
        if ( $#map == -1 ) {
            fail("Package {$cmds[0]} is not installed");
        }
        
        # more than one
        if ( $#map != 0 ) {
        
            # msg
            msg("There are more than one packages named {$cmds[0]}. Pick the one you want:");
            
            # counter to match options
            my $i = 0;
            
            # options
            foreach my $pid ( @map ) {
                $pkg = $packages->{$pid};
                if ( $pkg ) {
                    msg(" [$i] $pkg->{project}/$pkg->{meta}->{name}");
                }
            }
    
            # pick            
    		$pick = <>;
    		chomp $pick;
    		
    		# package
    		$pid = $map[$pick];
            
        }
        else {
            $pid = $map[0];
        }
        
        # package
        $package = $packages->{$pid};
    
        # no package
        unless ( $package ) {
            fail("Could not find the package you requested.");
        }
        
        # settings
        my $settings = $SETTINGS->get($pid);
            
        # if no options we need to just show all the settings
        if ( $#cmds == 0 ) {
            
            # msg
            msg("Settings for $package->{meta}->{name}");
            
            # loop and show
            foreach my $key ( keys %{$settings} ) {
                msg(" $key: $settings->{$key}");
            }
            
        }
        
        # set a settings
        else {
        
            # shift off package
            shift @cmds;
            
            # foreach of these do a set
            foreach my $c ( @cmds ) {
            
                # split on =
                ($key,$val) = split(/=/,$c);
                
                # reset
                $settings->{$key} = $val;
                
                # tell them what we changed
                msg("$package->{meta}->{name}.$key: $val");
                
            }
        
        }
    
    }

    # list
    sub list {
        
        # project
        my $project = $options{'project'} || 'all'; 
            
        # get a list of packages
        my $packages = $PACKAGES->all('default');
        
        # array
        my @a = ();
        
        # loop
        foreach my $pid ( keys %{$packages} ) {
        
            # get the package            
            my $p = $packages->{$pid};        
            
            # if !project or $project = $pkg project
            if ( $project eq 'all' || $project eq $p->{project} ) {
                push (@a,$p);
            }
        
        }
                
        # print it 
        msg("Total of ".($#a+1)." Packages installed.");        
                
        # print them
        foreach my $pkg ( @a ) {
            msg(" $pkg->{project}/$pkg->{meta}->{name}-$pkg->{meta}->{version}");            
        }
        
    }

}

