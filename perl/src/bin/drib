#!/usr/bin/perl
#
#  drib
# =================================
#  (c) Copyright Travis Kuhl 2009-10
#  
#
# This is free software. You may redistribute copies of it under the terms of
# the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
# There is NO WARRANTY, to the extent permitted by law.
#

# our package
package drib;

# version
our $VERSION = "X";

# use packages
use Getopt::Long;
use Data::Dumper;
use File::Basename;
use File::Find;
use POSIX;
use Digest::MD5 qw(md5_hex);
use Crypt::CBC;
use JSON;

# lib
use lib "../lib";

# drib packages
use drib::utils;
use drib::external;
use drib::db;
use drib::host;


# out of the box parsers
my %Parsers = (
	'dpf'	=> "drib::parser::text",	# drib package file
	'dppf'	=> "drib::parser::perl",	# drib perl package file
	'djpf'	=> "drib::parser::json",	# drib json package file
	'pkg'	=> "drib::parser::perl"		# for backwards compatability
);

# act 
my $act = 'help';

# need at least one argv
if ( $#ARGV != -1 ) {

    # act 
    $act = $ARGV[0];
    
}

# content
my $ocmd = join(" ",@ARGV);

# aliases
my %Alias = (   
    'ls'=>'list',
    'h'=>'help',
    'i'=>'install', 'in' => 'install', 'inst' => 'install',
    'c'=>'create',
    'rm'=>'remove', 'r' => 'remove'
);

# what are the avail commands
my $Commands = {
	
    # !help
	'help' => {
	   'func' => \&help,
	   'help' => 'Show this message',
	   'opts' => {
	       'version' => 'version|v'
	   }
    },
    
    # !setup
	'setup' => {
        'func' => \&setup,
        'help' => "Install the downloaded version of drib",
	   'opts' => {
            'type'=>'type|t=s',
	   }        
    },
        
    # !config 
    'config' => {
        'func' => \&config,
        'help' => "View or update drib configuration settings",
        'opts' => {}
    },    
    
    # !install
	'install' => {
        'func' => \&install,
        'help' => "Install a package from dist",
        'opts' => {
            'cleanup'=>'cleanup|c',        
            'project'=>'project|p=s',
            'version'=>'version=s',
            'branch'=>'branch=s',
            'same' => 'same|s',
            'downgrade' => 'downgrade',
            'host' => 'host|h=s'
        }
    },
    
    # !create
	'create' => {
        'func' => \&create,
        'help' => "Create a package",
        'opts' => {
            'project'=>'project|p=s',
            'install'=>'install|i',            
            'dist'=>'dist|d',
            'cleanup'=>'cleanup|c',
            'type'=>'type|t=s',                
        }        
    },
    
    # !set 
    'set' => {
        'func' => \&set,
        'help' => "Set package variables",
        'opts' => {
            'files' => 'files!',
            'host' => 'host|h=s'            
        }
    },
   
    # !unset 
    'unset' => {
        'func' => \&unset,
        'help' => 'Unset package variables',
        'opts' => {
            'yes' => 'yes|y'
        }    
    },
    
    # !list
    'list' => {
        'func' => \&list,
        'help' => "List all installed packages",
        'opts' => {
            'project' => 'project|p=s'
        }
    },
    
    # !remove
    'remove' => {
        'func' => \&rm,
        'help' => "Remove installed packages",
        'opts' => {
            'force' => 'force|f',
            'yes' => 'yes|y',
            'unset' => 'unset|u',
        }
    },
    
    # !dist
    'dist' => {
    	'func' => \&dist,
    	'help' => "Send a package to dist",
    	'opts' => {
            'branch'=>'branch|b=s',	
    	}
    },
    
    # !build
    'build' => {
		'func' => \&build,    
		'help' => "Build several packages based on a given build manifest",
		'opts' => {		
		}    
    }
	
};

my $CONFIG = 0;
my $DIST = 0;
my $PACKAGES = 0;
my $SETTINGS = 0;
my $CRONS = 0;

# if we self-install, we don't need
# dist or config, mostly because it doesn't 
# really exist
unless ( $act eq 'setup' || $act eq 'config' ) {
	
	# find our var
	my $var = dirname((-f $0 ? $0 : readlink($0))) . "/../var/drib/";
	
	# set some thigns	
    $CONFIG     = new drib::db('config',$var);	  
    $PACKAGES   = new drib::db('packges',$var);
	$SETTINGS   = new drib::db('settings',$var);
	$CRONS 	  	= new drib::db('crons',$var);
	
    # figure our what dist package to use
    my $mod = $CONFIG->get('dist') || "drib::dist::drib";
    
    # use 
    use drib::dist::drib;
    use drib::dist::remote;

    # create a dist object
    $DIST = new $mod($CONFIG);  

    # define what happens when we end
    END {
        $CONFIG->save() if $CONFIG;
        $PACKAGES->save() if $PACKAGES;
        $SETTINGS->save() if $SETTINGS;
        $CRONS->save() if $CRONS;
    }
	
}

# load config if we in config 
if ( $act eq "config" ) {

	# find our var
	my $var = dirname((-f $0 ? $0 : readlink($0))) . "/../var/drib/";
	
	# get config
    $CONFIG     = new drib::db('config',$var);	  

    # define what happens when we end
    END {
        $CONFIG->save() if $CONFIG;
    }

}

# check for a map 
if ( exists $Alias{$act} ) {
    $act = $Alias{$act};
}

# is the given command correct
unless ( exists $Commands->{$act} ) {
    $act = 'help';
}

# get options
my %options = ();

    # opts
    my $opts = $Commands->{$act}->{opts};
    
    # get options
    GetOptions(\%options, values %{$opts}); 

# cmds 
my @cmds = @ARGV; shift @cmds;

# not help need root
if ( $act ne 'help' && $> != 0 ) {
    fail("You must run as root.");
}

# call it 
$Commands->{$act}->{func}();

# done
exit 1;






###############################################################
### @brief display help information
###############################################################
sub help {

    # check if we want to show the version
    if ( $options{'version'} ) {
    
        # fail with version
        fail("drib $VERSION\nCopyright (C) Travis Kuhl 2009-10\n\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\nThere is NO WARRANTY, to the extent permitted by law.");
    
    }
    elsif ( $#cmds != -1 ) {
    
        # my
        my $c = $cmds[0];
        my $opts = ();
    
        # is it a valid command
        unless ( exists $Commands->{$c} ) {
            fail("Invalid Command.");
        }
        
        # if options
        foreach my $o ( keys %{$Commands->{$c}->{opts}} ) {
            if ( index($Commands->{$c}->{opts}->{$o},'=') != -1 ) {
                push(@opts,"--$o=[$o]");
            }
            else {            
                push(@opts,"--$o");
            }
        }
    
        # print out the usage
        msg("usage: drib [options] $c " . join(' ',@opts));
        msg($Commands->{$c}->{help});
    
    }
    else {
    
        # usage
        msg("usage: drib [options] command [sub-command] [command-options]\n\nList of Commands:");
        
        # show them commands
        foreach my $key ( keys %{$Commands} ) {
            printf(" %-20s %s\n", "$key","$Commands->{$key}->{help}");
        }
        
        # nothing more to do
        exit;
        
    }

}


###############################################################
### @brief setup the env for drib
###		   and create the nneed files
###############################################################
sub setup {

	# what we need
	my ($conf,$var);
    
    # shift off install
    shift @ARGV;

	# ask
	my @Ask = (
	    ['username',"What is your drib.it Username",""],
		['key', "What is your drib.it API Key",""],
		['secret',"What is your drib.it API Secret",""],
		['project',"What would you like your default project to be?","default"],
	);

	# ask them some questions
	foreach my $a ( @Ask ) {
		
		# back to an array
		@v = @{$a};
		
		if ( $#v == 2 ) {
			print $v[1]." [".$v[2]."]: "; 
		}
		else {
			print $v[1].": ";
		}
		$var = <>;
		chomp $var;
		if ( $var eq "" ) {
			$var = $v[2];
		}
		$conf->{$v[0]} = $var;
	}  	
	
	# need them
    if ( $conf->{'username'} eq "" || $conf->{'key'} eq "" || $conf->{'secret'} eq "" ) {
        fail("You didn't enter a Username, API Key or Secret. You need to do that before we can install.");
	}
	
	# find our var
	my $pwd = dirname((-f $0 ? $0 : readlink($0)));
	
	# tmp set it
    $conf->{'varf'} .= "$pwd/../var/drib";
    $conf->{'tmpf'} .= "/tmp/drib";	
    
	# make our var
	`sudo mkdir -p $conf->{'varf'}`;
	`sudo mkdir -p $conf->{'tmpf'}`;
	
	# save our json conf
	my $json = to_json({'default'=>$conf});
	
	# create our conf file
	file_put($conf->{'varf'}."/config.json",$json);
    
    # conifg
    $CONFIG = new drib::db('config',$conf->{'varf'});
    $PACKAGES = new drib::db('packges',$conf->{'varf'});
	$SETTINGS = new drib::db('settings',$conf->{'varf'});    
    
    # set our options
    $options{'dist'} = 0;
    $options{'install'} = 1;
    $options{'cleanup'} = 1;
        
}


###############################################################
### @brief set or display config variables
###############################################################
sub config {

    # if no commands they must want to view the corrent setings
    if ( $#cmds == -1 ) {
    
        # all
        my $config = $CONFIG->all();
    
        # loop through and print them
        foreach my $c ( keys %{$config} ) {
            msg(" $c: $config->{$c} ");
        }
    
    }
    else {
    
        # for each of them set the config
        foreach my $c ( @cmds ) {
            my($key,$val) = split(/\=/,$c);
            $CONFIG->set($key,$val);
            msg("set $key: $val");
        }
        
        # message
        fail("Configuration Updated");
        
    }

}


###############################################################
### @brief command line install of package(s)
###############################################################
sub install {

	# need a package name
	if ( $#cmds == -1 && !$pkg_file ) { fail("No Package Given"); }

	# loop me up
	foreach my $p ( @cmds ) {
		
		# try to isntall
		my $r = _do_install( $p );
			
		# tell them we're done
		msg($r->{response});		
	
	}
	
}


###############################################################
### @brief inernal install function.
###
### @param $pkg_file package file (package name|tar)
### @return string with result message
###############################################################
sub _do_install {
	
	# given a file
	my ($pkg_file) = @_;
	
	# get commands
	my ($pkg,$version,$file,$project);
	
	# check for host
	if ( $options{'host'} ) {
		
		# remove host
		$ocmd =~ s/-h(ost)?=?.*//gi;
		
		# host
		my $h = new drib::host($options{'host'});
		
		# cmd
		$cmd = "sudo drib " . $ocmd;
		
		# run the command
		my ($r,$msg) = $h->cmd($cmd);
		
		# tell them
		if ( $r ) {
			return {
				"code" => 200,
				"response" => "$pkg_file was installed on $options{'host'}",
			}
		}
		else {
			return {
				"code" => 400,
				"response" => "$pkg_file could not be installed on $options{'host'}"
			};
		}
	
	}
	
	# where are we now
	my $start_pwd = getcwd();  	
	
	# manifest
	my $manifest = 0;
	my $local = 0;
	
	# if package has .tar.gz
	# we don't need to go to dist
	if ( $pkg_file =~ /\.tar\.gz/ ) {    
	    
        # where
        unless ( -e "./$pkg_file" ) {
            return {
            	"code" => 404,
            	"response" => "Package file $pkg_file does not exists"
            };
        }
     
        # get it 
        $file = file_get($pkg_file);	
        
        # if cleanup
        if ( $options{'cleanup'} ) {
            `sudo rm $pkg_file`;
        }
        
        # manifest
        my $r = _unpack_package_tar($file);
        
        # save it
        $manifest = $r->{manifest};
        
        # local
        $local = $pkg_file;
        $local =~ s/\.tar\.gz//;
        
        # add to manifest
        $manifest->{meta}->{local} = $local;
        
	}
	else {
	
        # get package name
        my $p = _parse_pkg_name($pkg_file);
        
        # set it 
        $project    = $p->{project};
        $pkg        = $p->{name};
        $version    = $p->{version} || 'current';
    	
        # check for external projects
        if ( in_array(\@external::PROJECTS,$project) ) {
        
            # what happeend
            return &external::_map($project,$pkg,$version);
            
        }    
    
    	# now we need to check with dist 
    	# to see if this package exists 
    	my $exists = $DIST->check($project,$pkg,$version);
    
    	# if it exists we need to error
    	unless ( $exists ) {
    		return {
    			"code" => 404,
    			"response" => "Package $pkg-$version does not exist."
    		};
    	}
    
    	# ok so we now have it 
    	# so lets get the file
    	$file = $DIST->get($project,$pkg,$version);    
    
    	# unpack
    	my $r  = _unpack_package_tar($file);
    	
    	# set it 
    	$manifest = $r->{manifest};
    
    	# check if the package ist installed
    	my $installed = $PACKAGES->get($p->{pid});
    
    		# if yes is it the same version
    		if ( $installed ) {
    		
                # check if the same version is installed
                if ( $installed->{meta}->{version} eq $manifest->{meta}->{version} && !$options{'same'} ) {
                    return {
                    	"code" => 409,
                    	"response" => "$pkg-$installed->{meta}->{version} is already installed"
                    };
                }
                
                # check if the give version is smaller than the 
                # one installed
                if ( versioncmp($manifest->{meta}->{version},$installed->{meta}->{version}) == -1 && !$options{'downgrade'} ) {
                    return {
                    	"code" => 409,
                    	"response" => "$pkg-$exists is less than the installed version ($installed->{meta}->{version}).\nUse --downgrade to override."
                    };
                }
                
    		}
    		    		    	
    }

	# no manifest
	if ( $manifest == 0 ) {
		return {
			"code" => 500,
			"response" => "Manifest is unknow. Try Again."
		};
	}
	
	# lets see if there are any depend
	if ( $manifest->{depend} ) {
		
		# install
		my @install = ();
		
		# lets loop through and see if the packages
		# they've requested are installed
		foreach my $item ( @{$manifest->{depend}} ) {
			
			# parse a package name
			my $p = _parse_pkg_name($item->{pkg});
			
			# package
			my $i = $PACKAGES->get($p->{pid});
			
			# min and max
			my $min = $item->{min} || 0;
			my $max = $item->{max} || 0;
			my $ver = $item->{version} || 0;
		
			# if it's insatlled we need to check
			# min and max
			if ( $i ) {
			
				# is there a min and max
				if ( $ver != 0 && $ver != $i->{meta}->{version} ) {
					return {
						"code" => 409,
						"response" => "Installed version of $i->{meta}->{name} ($i->{meta}->{version}) does not meet $manifest->{meta}->{name} version requirement ($min)"
					};
				}			
			
				# is there a min and max
				if ( $min != 0 && versioncmp($i->{meta}->{version},$min) == -1 ) {
					return {
						"code" => 409,
						"response" => "Installed version of $i->{meta}->{name} ($i->{meta}->{version}) does not meet $manifest->{meta}->{name} minimun requirement ($min)"
					};
				}

				# is there a min and max
				if ( $max != 0 && versioncmp($max,$i->{meta}->{version}) == -1 ) {
					return {
						"code" => 409,
						"response" => "Installed version of $i->{meta}->{name} ($i->{meta}->{version}) does not meet $manifest->{meta}->{name} maximum requirement ($max)"
					};
				}				
				
			}
			else {
				
				# is there a version
				if ( $ver == 0 ) {
					$ver = $options{'branch'} || 'current';
				}
				
				# package name
				my $pn = $p->{project} ."/" . $p->{name} . "-" . $ver;
				
				# push to install
				push(@install,$pn);
				
			}
		
		}
		
		# are their files to install
		if ( $#install != -1 ) {		
		
			# install
			foreach my $p ( @install ) {
				
				# return
				my $r = _do_install($p);
				
				# try to install
				msg($r->{response});
			
			}
			
			# move back to start pwd
			chdir $start_pwd;			
			
			# now try reinstalling the package file
			return _do_install($pkg_file);		
			
		}
	
	}
	
	
	# get a package name
	my $p = _parse_pkg_name($manifest->{project}."/".$manifest->{meta}->{name});
	
	# check if the package ist installed
	my $installed = $PACKAGES->get($p->{pid});
	
		# installed we should remove
		if ( $installed ) {
		    
			# since we're still moving on
			# we need to remove the current file
			my @rm = ($p);	
			
			# remove 
			_remove(\@rm);		   

		}
	
	# check if it's a secure package
	if ( $manifest->{secure} != 0 && -e $tdir."/encrypted" ) {
	
		# ask for the passphrase 
		my $passphrase = md5_hex( ask("This package is secured, please enter the Passphrase:",1) );

		# now try to encrypt that tar file
		my $cipher = Crypt::CBC->new( 
			-key 	=> $passphrase,
			-cipher => 'Blowfish'
		);
	
		# open the encrypted file
		my $enc = file_get("$tdir/encrypted");
	
		# try to unencrypt the file
		my $tar = $cipher->decrypt($enc);
	
		# now put it pack
		file_put("$tdir/secure.tar",$tar);
	
		# try to untar it 
		`sudo tar -xf $tdir/secure.tar 2>/dev/null`;
	
		# check for a good file
		if ( -e "$tdir/secure/.good" ) {
		
			# move everything from secure into tdir
			`sudo mv -f $tdir/secure/* $tdir`;		
					
			# remove some files
			`sudo rm -rf $tdir/.good $tdir/encrypted $tdir/secure $tdir/secure.tar`;
			
			# should be good to go now
		
		}
		else {
			return {
				"code" => 403,
				"response" => "The Passphrase you tried for '".$manifest->{meta}->{name}."' was incorrect. Try again!"
			};
		}
	
	}
	
	
	# run pre-install commands
	_exec_commands($manifest,'pre-install');
	
	# now lets get a list of all directories
	# and move them into place
	opendir(my $dh, '.');
	my @dirs = readdir($dh);
	close($dh);
	
	# loop and move each of the 
	# files to root. we force the 
	# move. so if any existing folders 
	foreach my $d ( @dirs ) {
		if ( $d ne '.' && $d ne '..' && -d $d ) {			
			`sudo cp -rf ./$d /`;
		}
	}

    # make a pid
    my $pid = _get_pid($manifest->{project},$manifest->{meta}->{name});
    
    # don't need raw or changelog
    $manifest->{raw} = "";
    $manifest->{changelog} = "";
    
	# add package to our package db
	$PACKAGES->set($pid,$manifest);
    
    # set it 
    $PACKAGES->add($manifest->{meta}->{name},$pid,'map');

	# get settings for this file 
	my $curset = $SETTINGS->get($pid) || {}; 

    # any settings should always stay the same
    foreach $k ( keys %{$manifest->{set}} ) {
	    unless ( defined $curset->{$k} ) {
			$curset->{$k} = $manifest->{set}->{$k};
    	}
    }
    
    # set settings
    $SETTINGS->set($pid,$curset);
    
    # set files
    $SETTINGS->set($pid,$manifest->{set_files},'files');
    
    # _update_settings_txt_file
    _update_settings_txt_file();

    # perform set file updates
    _write_settings_files($manifest->{set_files},$curset);

	# cron 
	if ( $manifest->{crons} ) {

		# crons 
		my @crons = ();

		# loop me
		foreach my $c ( @{$manifest->{crons}} ) { 
			push(@crons,$c->{cmd});
		}	

		# add to package list
		$CRONS->set($pid,\@crons);
	
		# update
		_rebuild_crons();
	
	}


    # cleanup our tmp dir
    `sudo rm -fr $tdir`;    
    
	# run pre-install commands
	_exec_commands($manifest,'post-install');    

	# tell them what up
	return {
		"code" => 200,
		"response" => "Package $manifest->{meta}->{name} installed!"
	};
	
}


###############################################################
### @brief command line to create a package
###############################################################
sub create {
	
	# file
	my @file = ();
	
	# where are we now
	my $pwd = getcwd();    	
	
	# package files
	if ($#cmds != -1) {
		push(@file,$cmds[0]);
	}
	else {
	
		# open the directory and see if there's a pkg file	
		opendir(my $dh, $pwd);
		my @files = grep { $_ =~ /\.(pkg|dpf|djpf)/ } readdir($dh);
		closedir $dh;
		
		# if yes set as file
		if ( $#files != -1 ) {
			@file = @files;
		}

	}
	
	# still no file 
	if ( $#file == -1 ) {
		
		my $r = ask("Would you like to recursivly build all files in this directory. [n]");
		
		# ask if they want to build the directory
		if ( lc(substr($r,0,1)) eq "y" ) {
			
			# search the directory
			foreach my $f ( @{search_dir($pwd,"*.pkg")} ) {
				my @n = split(/\//,$f);
			
				if ( lc(substr(ask(" Build $n[$#n] [y]:"),0,1)) ne 'n' ) {
					push(@file,$f);
				}
			}
			
		}
		
	}
		
	# make sure we have a file
	if ( $#file == -1 ) {
		fail("No Package file given.");
	}
	
	# do create
	foreach my $f (@file) {
		
		# response
		my $r = _do_create($f);
		
		# msg 
		msg( $r->{response} );
		
	}
	
}



###############################################################
### @brief internal create function
###
### @param $file path to manifest file
### @return result string
###############################################################
sub _do_create {

	my ($file) = @_;

	# optns
	my $dist = $options{'dist'};
	my $branch = $options{'branch'} || 'current';
	my $type = $options{'type'} || 'release';
	my $install = $options{'install'} || 0;

        # not defined
        unless ( defined $options{'dist'} ) {
            $dist = 1;
        }
	
	# where are we now
	my $pwd = getcwd();    		
	
	# make sure we're in the correct folder
    my ($fname,$fpath) = fileparse($file);	
		
    # move into fpath
    chdir $fpath;

	# open the manifest
	my $man = file_get($fname);

	# check if the first two chars are 
	# a hash bang
	if ( substr($man,0,2) eq "#!" ) {
		$man = `sudo $file`;
	}

	# save the man as a tmp file
	my $tmp = $CONFIG->get('tmpf') . "/" . rand_str(5);

	# put the man
	file_put($tmp,$man);
	
	# pick a parser
	my ($parser,$pfile) = _pick_parser($file);

	# use 
	require "$pfile";

	# parse me 
	my $p = $parser->parse($tmp);

	# what we need 
	# this is just to keep backwards compatable 
	# with perl parser
	my $Meta		= $p->{meta};
	my $Set 		= $p->{set};
	my $Dirs 		= $p->{dirs};
	my $Files		= $p->{files};
	my $Commands	= $p->{cmd};
	my $Depend 		= $p->{depend};
	my $Cron 		= $p->{cron};

	# we need the package name
	my $pkg = $Meta->{name};
	my $version = $Meta->{version};
	my $project = $options{project} || $CONFIG->get('project');
	my $vff = 0;
	
		# figure if version is a file we have to look in
		if ( $version =~ /file\:/ ) {
			
			# remove the file
			$version =~ s/file\://;				
			
			# open the file 
			my $f = file_get($version) =~ /Version ([0-9\.]+)/i;

			# get the version file
			$vff = $pwd .'/'. $version;			
			
			# set hte verison
			$version = $Meta->{version} = $1;	
			
		}
	
	   # is project defined in meta
	   if ( exists $Meta->{project} ) {
	       $project = $Meta->{project};
	   }
	   
    # version
    if ( $type eq "symlink" || $type eq "s" ) {
        $version = "$version.S".time();        
        $dist = 0;
    }
    elsif ( $type eq "beta" || $type eq "b" ) {
    
        # version
        $version = "$version.B".time();
        
        # branch
        $branch = "beta";
        
    }
    elsif ( $type eq "nightly" || $type eq 't' ) {
    
        # version
        $version = "$version.N".time();    
        
        # bracnh
        $branch = "nightly";
        
    }
    elsif ( $type eq "qa" || $type eq 'q' ) {
    
        # version
        $version = "$version.QA".time();    
        
        # bracnh
        $branch = "qa";
        
    }
	
	# pass
	my $passphrase = 0;

	# check if this is a secure pacakge
	if ( defined $Meta->{secure} ) {
		$passphrase = md5_hex( ask("Enter a Passphrase for this package:",1) );
	}
	else {
		$Meta->{secure} = 0;
	}

	# now we need to create a tmp director
	my $tdir_name = rand_str(10);
	my $tdir = $CONFIG->get('tmpf') . "/" . $tdir_name;

	# create the dir
	`sudo mkdir $tdir`;
	
	# listsings of what we've created
	my @listing = ();

	# now create and dirs they want
	if ( $Dirs != 0 ) {
		foreach my $dir ( @{$Dirs} ) {
		
			# ref
			unless ( ref($dir) eq "HASH" ) {
				$dir = { 'dir' => $dir };
			}
		
			# name		
			my $d = $tdir . "/" . trim($dir->{dir},1);
			
			# mkdir 
			`sudo mkdir -p $d`;

				# if user
				if ( defined $dir->{user} ) {
					`sudo chown $dir->{user} $d`;
				}
				
				# group
				if ( defined $dir->{group} ) {
					`sudo chown :$dir->{group} $d`;
				}
				
				# mode
				if ( defined $dir->{mode} ) {
					`sudo chmod $dir->{mode} $d`;
				}

			# add listing
			push(@listing,$d);
			
		}
	}
	
	# setting files
	my @SettingFiles = ();
	
	# no files
	if ( $Files != 0 ) {
		foreach my $f ( @{$Files} ) {
			
			# where are we going
			my $d = $tdir . trim($f->[0]);
			
			# if the dest doesn't exist 
			# we need to create it 
			unless ( -e $d ) {				
				`sudo mkdir -p $d`;			
			}
			
			# all the files
			my @files = ();
			
			# now figure out if src is a
			# single file or a ref
			unless ( ref($f->[1]) eq "HASH" ) {
				$f->[1] = {'src'=>$f->[1]};
			}
			
			# files
			my $file = $f->[1];
			
			# check if we have one file or many
			if ( defined $file->{src} ) {
				
				# add it
				push(@files,$file);
								
			}
			else {
			
				# check for lfind
				if ( defined $file->{find} ) {
					
					# run the find
					my $r = `sudo find $file->{find}`;
					my $root = "";
					
					# root 
					if ( defined $file->{root} ) {
					   $root = trim($file->{root});
					}
										
					# each file
					foreach my $item ( split(/\n/,$r) ) {
					   
                        # parse the file path
                        my ($fname,$fpath) = fileparse($item);
                        
                        # append
                        $append = "";
                        
                        # if path does not eq root
                        # we need to append the subdir to the 
                        # final dest also
                        if ( $root ne "" && trim($fpath) ne $root ) {
                            $fpath =~ s/$root//;
                            $append = $fpath;
                        }
					
                        # push ontop
						push(@files,{
                            'src'=>$item,
                            'user'=>$file->{user},
                            'group'=>$file->{group},
                            'mode'=>$file->{mode},
                            'append'=>$append,
                            'settings' => $file->{settings}
                        });
						
					}
					
				}
				elsif ( defined $file->{'glob'} ) {
				
				    # glob it up
				    my @r = glob $file->{'glob'};				    
					my $root = "";
					
					# root 
					if ( defined $file->{root} ) {
					   $root = trim($file->{root});
					}
										
					# each file
					foreach my $item ( @r ) {
					   
                        # parse the file path
                        my ($fname,$fpath) = fileparse($item);
                        
                        # append
                        $append = "";
                        
                        # if path does not eq root
                        # we need to append the subdir to the 
                        # final dest also
                        if ( $root ne "" && trim($fpath) ne $root ) {
                            $fpath =~ s/$root//;
                            $append = $fpath;
                        }
					
                        # push ontop
						push(@files,{
                            'src'=>$item,
                            'user'=>$file->{user},
                            'group'=>$file->{group},
                            'mode'=>$file->{mode},
                            'append'=>$append,
                            'settings' => $file->{settings}
                        });
						
					}				    
				
				}
			
			}
			
			# loop through each file
			foreach my $item ( @files ) {
		
				# filename
				my $n = basename($item->{src});
		
				# dest
				my $_d = "$d/$n";				
				
				# check for append
				if ( defined $item->{append} && $item->{append} ne "" ) {
				
				    # append
				    $_d = "$d$item->{append}";
				    
				    # directory may not exist. we need to create it
				    unless ( -d $_d ) {
				        `sudo mkdir -p $_d`;
				    }
				    
				    # append name
				    $_d .= $n;
				    
				}
				
				# push
				push(@listing,$_d);
				
				my $isSet = 0;
				
				# settings
                if ( defined $item->{settings} && $item->{settings} eq 'true' ) {
                
                    # dest file
                    my $sfd = $_d;
                       $sfd =~ s/$tdir//g;
                       
                    # push it 
                    push(@SettingFiles,{'file' => $sfd, 'tmpl' => file_get($item->{src}) });
                    
                    # isset 
                    $isSet = 1;
                    
                }               
                
                # now see what type of build we have
                if ( ( $type eq 'symlink' || $type eq 's' ) && $isSet != 1 ) {
                    my $_s = getcwd() . "/" . $item->{src};				
                    symlink $_s, $_d;
                }
                else {	
    				`sudo cp $item->{src} $_d`;
                }
			
				# if user
				if ( defined $item->{user} ) {
					`sudo chown $item->{user} $_d`;
				}
				
				# group
				if ( defined $item->{group} ) {
					`sudo chown :$item->{group} $_d`;
				}
				
				# mode
				if ( defined $item->{mode} ) {
					`sudo chmod $item->{mode} $_d`;
				}
		
		        # rename
		        if ( defined $item->{rename} ) {
                    `sudo mv $_d $d/$item->{rename}`;
		        }
		  
			}
							
		}
	} # END @files	
		
	
	# nice list of files
	my @nicelist = map { s/$tdir//g; $_; } @listing;
	
	# move to our folder
	chdir $tdir;	
	
	# if they want a secure package
	# we need to move everything into a secure directory
	if ( $passphrase != 0 ) {
	
		# make secure
		`sudo mkdir $tdir/secure`;
		
		# move all files and dirst that are not secure
		opendir(my $dh, $tdir);
			foreach my $xf ( readdir($dh) ) {
				if ( $xf ne "." && $xf ne ".." && $xf ne "secure" ) {			
					`sudo mv $tdir/$xf $tdir/secure`;
				}
			}
		closedir($dh);
		
		# add our good file
		file_put("$tdir/secure/.good","1");
	
		# now tar just that file
		`sudo tar -cf secure.tar ./secure`;
	
		# now try to encrypt that tar file
		my $cipher = Crypt::CBC->new( 
			-key 	=> $passphrase,
			-cipher => 'Blowfish'
		);
		
		# get the securet
		my $sec_file = file_get($tdir."/secure.tar");
	
		# do it 
		my $encrypted = $cipher->encrypt($sec_file);
	
		# remove the tar and save back
		`sudo rm -rf $tdir/secure`; 	
		`sudo rm $tdir/secure.tar`;
	
		# put it in there
		file_put($tdir."/encrypted",$encrypted);
	
	}
	
    # changelog
	$cl = file_get($pwd.'/'.$Meta->{changelog}) || "";
	
	# need to create our own version of the manifest
	my $manifest = {
	    'project' => $project,
		'type' => $type,	
		'meta' => $Meta,
		'secure' => $Meta->{secure},
		'set' => $Set,
		'set_files' => \@SettingFiles,
		'crons' => $Cron,
		'commands' => $Commands,
		'raw' => $man,
		'changelog' => $cl,
		'depend' => $Depend,
		'buildenv' => {
			'user' => $ENV{'USER'},
			'host' => $ENV{'HOSTNAME'},
			'pwd' => $ENV{'PWD'}			
		},
		'ov' => $vff,
		'files' => \@nicelist
	};
	
	# add our manifest to the build 
	file_put($tdir."/.manifest", to_json($manifest) );
	
	# name 
	my $name = "$pkg-$version";

	# tar 
	`sudo tar -czf $name.tar.gz .`;
	
	# package
	my $package = "$tdir/$pkg-$version.tar.gz";
	
	# dist
	if ( $type eq 'release' && $options{'dist'} == 1 ) {
	
		# we want to do dist
		return _do_dist("$name.tar.gz");
	
	}
	else {
	
	    # or move the file back to the pwd 
		`sudo mv $package $pwd`;
		
	}

	# remove our tmp dir
	`sudo rm -r $tdir`;
		
    # move back to current
    chdir $pwd;    	

    # install
    if ( $install ) {
     
        # run install
        return _do_install($name.".tar.gz");
        
    }
    else {
   
    	# done
    	return {
    		"code" => 200,
    		"name" => $name,
    		"response" => "Package Created: $name"
    	};
    	
    }

}


###############################################################
### @brief set or display a list of settings
###############################################################
sub set {

	# check for host
	if ( $options{'host'} ) {
		
		# remove host
		$ocmd =~ s/-h(ost)?=?.*//gi;
		
		# host
		my $h = new drib::host($options{'host'});
		
		# cmd
		$cmd = "sudo drib " . $ocmd;
		
		# run the command
		my ($r,$msg) = $h->cmd($cmd);
		
		# tell them
		fail($msg);
	
	}

    # packages
	my $packages = $PACKAGES->all();    

	# no subcommand we assume to show all packages
	if ( $#cmds == -1 ) { 
	
        # get all settings
        my $settings = $SETTINGS->all();
	
        # print them
        foreach my $pid ( keys %{$packages} ) {
            
            # settings
            my $s = $settings->{$pid};
            
            # only show if we have at least one setting
            if ( $s != 0 && ( ref $s eq "HASH" && scalar(keys %{$s}) > 0 ) ) {
            
                # print the package name            
                msg("$packages->{$pid}->{project}/$packages->{$pid}->{meta}->{name}");
                    
                # loop and show
                foreach my $key ( keys %{$s} ) {
                    msg(" $key: $s->{$key} ");
                }
                
                msg();
                
            }
            
        }
	
        # done
        exit();
	
    }
    

	# parse package name
	my $pkg = _parse_pkg_name($cmds[0]);
		
	# pid
	my $pid = $pkg->{pid};		
		
		# is package installed
		unless ( defined $packages->{$pid} ) {
			fail("Package $cmds[0] is not installed");
		}
		
    
    _exec_commands($packages->{$pid},'pre-set');		
		        
    # package
    $package = $packages->{$pid};
    
    # settings
    my $settings = $SETTINGS->get($pid);
        
    # if no options we need to just show all the settings
    if ( $#cmds == 0 ) {
        
        # msg
        msg("Settings for $package->{meta}->{name}");
        
        # loop and show
        foreach my $key ( keys %{$settings} ) {
            msg(" $key: $settings->{$key}");
        }
        
    }
    
    # set a settings
    else {
    
        # shift off package
        shift @cmds;
        
        # foreach of these do a set
        foreach my $c ( @cmds ) {
        
            # split on =
            ($key,$val) = split(/=/,$c);
            
            # reset
            $settings->{$key} = $val;
            
            # tell them what we changed
            msg("$package->{meta}->{name}.$key: $val");
            
        }
        
        # unless they tell us no
        if ( $options{'files'} eq undef || $options{'files'} != 0 ) { 
                    
            # update the files
            my $files = $SETTINGS->get($pid,'files');
                
            # update each settings file
            _write_settings_files($files,$settings);
            
        }
    
    }
    
    # regen text files
    _update_settings_txt_file();
    
    # exec post set
    _exec_commands($packages->{$pid},'post-set');

}


###############################################################
### @brief unset a package setting
###
### @param $pid package id
### @param $var name of variable to unset
### @param $stay do not fail after complete
### @return void
###############################################################
sub unset {

    # check if it's an internal call
    my ($pid,$var,$stay) = @_;

    # check cmd
    if ( $#cmds == -1 && $pid == 0 ) {
        fail("You have not provided a package and setting");
    }
    
    # vars
    my @vars = ();
    
    # pid
    unless ( $pid ) {
    
        # package
        my $pkg = _parse_pkg_name($cmds[0]);
    
        # pid
        $pid = $pkg->{pid};
        
        # shift off command
        shift @cmds;
        
        # add var
        push @vars, $var;
        
    }
    
    # make sure package is installed
    unless ( $PACKAGES->get($pid) ) {
        fail("Package is not installed");
    }

    # get all settings
    my $settings = $SETTINGS->get($pid);
    
    # now loop through and get settings
    foreach my $var ( @vars ) {
        delete $settings->{$var};
    }

    # reset settings
    $SETTINGS->set($pid,$settings);

    # regen text files
    _update_settings_txt_file();

    # done
    unless ($stay) {
        fail("Unset Complete");
    }

}


###############################################################
### @brief list packages installed
###############################################################
sub list {
    
    # project
    my $project = $options{'project'} || 'all'; 
        
		# did they give project as a cmd
		if ( $#cmds != -1 ) {
			$project = $cmds[0];
		}
        
    # get a list of packages
    my $packages = $PACKAGES->all('default');
    
    # array
	my %projects = ();
	my $total = 0;
    
    # loop
    foreach my $pid ( keys %{$packages} ) {
    
        # get the package            
        my $p = $packages->{$pid};        
	
		# either we're showing all
		# or we aren't showing all and we're showing the package
		if ( $project eq "all" || ( $project ne 'all' && $project eq $p->{project} ) ) {
		
			# push to projects
			$projects{$p->{project}} = () unless defined $projects{$p->{project}};
	    
	    	# add it
			$projects{$p->{project}}{$pid} = 1;
	    
	    	# one more
	    	$total++;
	    	
	    }
    
    }
            
    # print them
    foreach my $pr ( keys %projects ) {

		# name
		msg( $pr );
		
		# each package
		foreach my $pid ( keys %{$projects{$pr}} ) {
		
			# local
			my $local = "";
				
				# if local
				if ( defined $packages->{$pid}->{meta}->{local} ) {
					$local = " (Build: ".$packages->{$pid}->{meta}->{local}.")";
				}
	
		
			msg(" ".$packages->{$pid}->{meta}->{name}."-".$packages->{$pid}->{meta}->{version}.$local);
		}
	
		msg();
	
    }
    
    # print it 
    msg("-"x40);
    msg("Total of $total Packages installed.");     
    msg();
    
}


###############################################################
### @brief command line remove a package(s)
###############################################################
sub rm {

    # no packages?
    if ( $#cmds == -1 ) {
        fail("You must provide at lease one package to remove.");
    }

    # define the packages
    my @packages = ();
    
    # loop
    foreach my $name ( @cmds ) {
        push @packages, _parse_pkg_name($name);
    }

    # now make sure all packages are installed
    foreach my $p ( @packages ) {            
        unless ( $PACKAGES->get($p->{pid}) ) {
            fail("Package $p->{name} is not installed");
        }
    }
    
    # unless they've told us yes, ask if they want to remove the packages
    unless ( $options{'yes'} ) {
        
        # wait for an answer
        my $resp = ask("Are you sure you want to remove ".($#packages+1)." ".plural("package",$#packages). " [y|n]: ");
    
        
        # what
        if ( $resp ne "y" && $resp ne "yes" ) {
            fail("You said you don't want to remove them");
        }
    
    }

	# remove the packages
	_remove(\@packages);
    
    # done
    fail("Packages removed");

}


###############################################################
### @brief internal remove function
###
### @param $packages hash of packages to remove
### @return void
###############################################################
sub _remove {

	# get packages
	my ($packages) = @_;


    # now loop through the packages and remove
    foreach my $pkg ( @{$packages} ) {
    
        # get the manifest 
        my $manifest = $PACKAGES->get($pkg->{pid});
    
        # dirs
        my @dirs = ();
    
        # loop through the files array and remove
        # any files. after we'll loop through 
        foreach my $f ( @{$manifest->{files}} ) {
            
            # is a directory
            if ( -d $f ) {
                push @dirs, $f;
            }
            else {
                `sudo rm -f $f`;
            }
            
        }
         
        # now any directories
        foreach my $d ( @dirs ) {  
        
            # remove any empty sub dirs
            finddepth(sub { rmdir $_ if -d }, $d);
            
            # remove the dir
            unless ( $d = ~ /\.svn/i ) {
            	rmdir($d);
            }
            
        }

        # check if they want us to remove
        # the settings
        if ( $options{'unset'} ) {
            
            # settings
            my $settings = $SETTINGS->get($pid);            
            
            # get all settings for this package
            foreach my $k ( keys %{$settings} ) {
                &unset($pid,$k,1);
            }
   
        }
        
        # now remove the package from the packages db
        $PACKAGES->unset($pkg->{pid});
        
        # remove crons
        $CRONS->unset($pkg->{pid});
    
    }

	# rebuild crons
	_rebuild_crons();

}


###############################################################
### @brief comand line idst
###############################################################
sub dist {

    # no packages?
    if ( $#cmds == -1 ) {
        fail("You must provide at lease one package to dist.");
    }
	
	# where are we now
	my $pwd = getcwd();    	
	
	# package files
	if ($#cmds != -1) {
		push(@file,$cmds[0]);
	}
	else {
	
		# open the directory and see if there's a pkg file	
		opendir(my $dh, $pwd);
		my @files = grep { $_ =~ /\.tar\.gz/ } readdir($dh);
		closedir $dh;
		
		# if yes set as file
		if ( $#files != -1 ) {
			@file = @files;
		}

	}
	
	# still no file 
	if ( $#file == -1 ) {
		
		my $r = ask("Would you like to recursivly dist all package files in this directory. [n]");
		
		# ask if they want to build the directory
		if ( lc(substr($r,0,1)) eq "y" ) {
			
			# search the directory
			foreach my $f ( @{search_dir($pwd,"*.tar.tz")} ) {
				my @n = split(/\//,$f);
			
				if ( lc(substr(ask(" Build $n[$#n] [y]:"),0,1)) ne 'n' ) {
					push(@file,$f);
				}
			}
			
		}
		
	}
		
	# make sure we have a file
	if ( $#file == -1 ) {
		fail("No Build Manifest given");
	}
	
	# do create
	foreach my $f (@file) {
	
		# response
		$r = &_do_dist($f);
		
		# good
		msg($r->{response});
		
	}
	

}

###############################################################
### @brief command line remove a package(s)
###############################################################
sub _do_dist {

	# package file to send to dist
	my ($pkg,$branch) = @_;
	
	# no branch
	unless ( $branch ) {
		$branch = 'current';
	}
	
	# need package
	unless ( -e $pkg ) {
		return {
			"code" => 404,
			"response" => "Could not find package $pkg to dist"	
		};
	}
	
	# file
	my $file = file_get($pkg);
	
	# unpack the package file
	my $r = _unpack_package_tar( $file );
	
	# manifest
	my $man = $r->{manifest};
	my $tmp = $r->{tmp};
	
		# could not tar
		unless ( $man ) {
			return {
				"code" => 400,
				"response" => "Could not untar package file"	
			};			
		}
		
	my $project = $man->{project};
	my $name = $man->{meta}->{name};
	my $version = $man->{meta}->{version};

	if ( $DIST->check($project,$name,$version) ) {
	
		# see if they're using a file:
		if ( $man->{ov} && -e $man->{ov} ) {
			
			# ask them if they want to add to the file
			my $r = ask("Version $version already exists for $pkg. Would you like to up the version and add a comment? [y]");
			
			# if we get y
			if ( lc(substr($r,0,1)) eq "y" || $r eq "" ) {
				
				# one more
				my $iv = incr_version($version);
				
				# ask for the new version
				my $v = ask(" New version Number [".$iv."]:");
				
					# no number
					if ( $v eq "" ) {
						$v = $iv;
					}
				
				# comment
				my $c = ask(" Add Comments [n]:");

					if ( lc(substr($r,0,1)) eq "y" ) {
						
						# tmp file
						my $t = $CONFIG->get('tmpf') . "/" . rand_str(10);
						
						# launch
						system("vi $t");
						
						# get it 
						$c = file_get($t);
						
						# remove
						`rm $t`;
						
					}
			
				# open the file
				my $f = file_get("$tmp/changelog");
				
				# append our new stuff
				my $nf = "Version $v\n$c\n\n".$f;
				
				# save it 
				file_put("$tmp/changelog",$nf);	# to package
				file_put($man->{ov},$nf); # to vhangelog file
			
				# done
				# set the new version number
				$version = $man->{meta}->{version} = $v;

				# resave the manifest	
				file_put($tmp."/.manifest", to_json($man) );
			
				# pwd
				my $pwd = getcwd();
				
				# move into tmp
				chdir($tmp);
				
				# remove the tar
				`rm $pkg`;
				
				# repackage the tmp dir 			
				`sudo tar -czf $name.tar.gz .`;
				
				# package
				$file = file_get($tmp."/$name.tar.gz");
				
				# move back
				chdir($pwd);
				
			}
			else {			
				return {
					"code" => 403,
					"response" => "Package '$pkg' version '$version' already exists"
				};
			}				
			
		}
		else {			
			return {
				"code" => 403,
				"response" => "Package '$pkg' version '$version' already exists"
			};
		}		
		
	}	
	
	# upload
	$r = $DIST->upload({
	   'project'	=> $man->{project},
	   'username'	=> $CONFIG->get('username'),
	   'name'		=> $man->{meta}->{name},
	   'version'	=> $man->{meta}->{version},
	   'branch'		=> $branch,
	   'tar' 		=> $file
    });	
    
    # name
    my $n = $man->{project}."/".$man->{meta}->{name}."-".$man->{meta}->{version};
    
    # what happened
    if ( $r ) {
    	return {
    		'code' => 200,
    		'response' => "Package $n pushed to dist"
    	};
    }
    else {
    	return {
    		'code' => 500,
    		'response' => "Unknown error prevent dist"
    	};    
    }

}


###############################################################
### @brief build a package
###############################################################
sub build {

	# open the build file
    if ( $#cmds == -1 ) {
        fail("You must provide a build file");
    }
    
	# where are we now
	my $pwd = getcwd();    		

	# open the manifest
	my $man = file_get($cmds[0]);

	# save the man as a tmp file
	my $tmp = $CONFIG->get('tmpf') . "/" . rand_str(5);	
	
	# put the man
	file_put($tmp,$man);
		
	# what we need
	our $name = 0;
	our $branch = 'current';
	our $packages = 0;
	our $install = 0;
	
	# try to include the file
	eval {
		do "$tmp";
	};
	
	# need at least packages
	if ( $packages == 0 ) {
		fail("Need to provide a list of packages to build");
	}
	
	# try to open the build file
	my $builds = file_get(".$name") || {};
	
	# what was built 
	my @built = ();
	
	# lets look at each package
	# and check the svn status to
	# see if anything has changed since we last build 
	foreach my $pkg ( @{$packages} ) {
		
		# file
		my $f = $pkg->{pkg};
		
		# create the package
		my $r = _do_create($f);
		
		# if good 
		if ( $r->{code} == 200 ) {
			
			# tell them
			msg($r->{response});
			
			# built
			push(@built,$r->{name});
				
			# dist
			unless ( $pkg->{"no-dist"} ) {
				
				# dist
				_do_dist( $pkg->{name} );
				
			}		
			
		}	
		
	}

}


###############################################################
### @brief create a package id
###
### @param $project name of project
### @param $name name of the pakcage
### @return md5 hash of package id
###############################################################
sub _get_pid {
    
    # project
    my $project = shift;
    my $name = shift;
    
    # give back the hash
    return  md5_hex($project."-".$name);

}


###############################################################
### @brief parse input for project, package, version, pid
###
### @param $name string of input
### @return HASH {  name => pacakge name
###					project => project name
###					version => version number or branch
###					pid => package id
###				 }
###############################################################
sub _parse_pkg_name {
    
    # get the raw package name
    my $name = shift;

    # first explode for version
    ($part,$version) = split(/-/,$name);

    # now explode for the project and name
    ($project,$pkg) = split(/\//,$part);

    # if no pkg, it must not have a project
    if ( !$pkg ) {
        $pkg = $project;
        $project = 'default';
    }
    
    # check for branch flag
    if ( exists $options{'branch'} && !$version ) {
        $version = $options{'branch'};
    }

    # give back an object
    return { 'name' => $pkg, 'project' => $project, 'version' => $version, 'pid' => _get_pid($project,$pkg) };

}


###############################################################
### @brief write given settings to a file
### 
### @param $files list of files to update
### @param $settings settings to write
### @return void
###############################################################
sub _write_settings_files {
    
    # what 
    my $files = shift;
    my $settings = shift;

    # open each file
    foreach my $item ( @{$files} ) {
            
        # file
        my $file = $item->{file};
        
        # content            
        my $content =  $item->{tmpl};
    
        # loop through each setting
        foreach my $key ( keys %{$settings} ) {
            $content =~ s/\$\($key\)/$settings->{$key}/g;
        }
        
        # write back the file
        file_put($file,$content);
    
    }

}


###############################################################
### @brief execute post install commands
###############################################################
sub _exec_commands {
	
	# pwd
	my $pwd = getcwd();
	
	# move to /
	chdir("/");

    # get them
    my $manifest = shift;
    my $type = shift;

    # see if commands exists
    if ( exists $manifest->{commands} ) {
    
        # does this type of command exist
        if ( exists $manifest->{commands}->{$type} ) {
            
            # loop through and execute
            foreach my $c ( @{$manifest->{commands}->{$type}} ) {
                system($c);
            }
        
        }
    
    }
    
    # go back
    chdir($pwd);

}


###############################################################
### @brief update settings txt file
###############################################################
sub _update_settings_txt_file {

	# file
	$txt = "";

    # packages
	my $packages = $PACKAGES->all();    

    # get all settings
    my $settings = $SETTINGS->all();

    # print them
    foreach my $pid ( keys %{$packages} ) {
        
        # settings
        my $s = $settings->{$pid};
        
        # only show if we have at least one setting
        if ( $s != 0 && ( ref $s eq "HASH" && scalar(keys %{$s}) > 0 ) ) {
        
   
            # loop and show
            foreach my $key ( keys %{$s} ) {
                
				# set it 
				$txt .= $packages->{$pid}->{project}."_".$packages->{$pid}->{meta}->{name}."__".$key."|".$s->{$key}."\n";
                
            }
		
        }
        
    }	

	# save it
	file_put("/usr/var/drib/settings.txt",$txt);

}


###############################################################
### @brief unpack a package tar
###############################################################
sub _unpack_package_tar {

	# tar
	my ($file) = @_;

	# make a tmp dir
	my $tdir = $CONFIG->get('tmpf') . "/" . rand_str(10);
	
	# make it 
	`sudo mkdir $tdir`;
	
	# save the file to tdir 
	file_put($tdir."/pkg",$file);
	
	# now move into the tmp dir 
	chdir $tdir;
	
	# untar the file
	`sudo tar -xzf pkg`;
	
	# remove pkg
	`rm pkg`;
	
	# open our manifest
	return {
		'tmp' => "$tdir",
		'manifest' => from_json( file_get($tdir.'/.manifest') )
	};

}

###############################################################
### @brief unpack a package tar
###############################################################
sub _rebuild_crons {

	# get a crons
	my $crons = $CRONS->all();    	
	
	# file
	my $file = "";
	
	# get each package and 
	foreach my $pkg ( keys %{$crons} ) {
		foreach $cron ( @{$crons->{$pkg}} ) {
			$file .= $cron."\n";
		}
	}

	# save as tmp
	my $tmp = $CONFIG->get('tmpf') . "/" . rand_str(10);

	# put into tmp
	file_put($tmp,$file);

	# blast away the cron file
	`crontab -u root -r`;

	# set our new one
	`crontab -u root $tmp`;
	
	# no more temo
	`rm $tmp`;

	# done
	return true;
		
}

###############################################################
### @brief pick the parser to use
###############################################################
sub _pick_parser {

	# file
	my $file = shift;

	# parser
	my @parts = split(/\./,$file);

	# get the exension
	my $ext = pop(@parts);

	# does this exist in the parsers array
	if ( defined $Parsers{$ext} ) {

		# file 
		my $pf = $Parsers{$ext};
		   $pf =~ s/\:\:/\//g;

		# giver 
		return ($Parsers{$ext},$pf.".pm");

	}


}