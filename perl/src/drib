#!/usr/bin/perl -w
#
#  drib
# =================================
#  (c) Copyright Travis Kuhl 2009
#  
#

# our package
package drib;

# version
my $VERSION = "0.0.1";

# use packages
use Getopt::Long;
use Data::Dumper;
use JSON;
use File::Basename;
use POSIX;
use Digest::MD5 qw(md5_hex);

# where our var folder is
use constant VAR => "/usr/local/var/drib";
use constant LIB => "/usr/local/lib/drib";

# load our config
use lib LIB;

# drib packages
use dist::local;
use dist::remote;
use utils;
use db;

# act 
my $act = 'help';

# need at least one argv
if ( $#ARGV != -1 ) {

    # act 
    $act = $ARGV[0];
    
}

# what are the avail commands
my $Commands = {
	
    # help
	'help' => {
	   'func' => \&help,
	   'help' => 'Show this message',
	   'opts' => {
	       'version' => 'version|v'
	   }
    },
    
    # self-install
	'self-install' => {
        'func' => \&self_install,
        'help' => "Install the downloaded version of drib",
	   'opts' => {
	       'symlink' => 'symlink|s'
	   }        
    },
    
    # self-update
    'self-update' => {
        'func' => \&self_update,
        'help' => "Update drib to the given version",
        'opts' => {
            'version'=>'version=s',
            'branch'=>'branch=s'
        }
    },
    
    # install
	'install' => {
        'func' => \&install,
        'help' => "Install a package from dist",
        'opts' => {
            'project'=>'project|p=s',
            'version'=>'version=s',
            'branch'=>'branch=s'
        }
    },
    
    # create
	'create' => {
        'func' => \&create,
        "help" => "Create a package",
        'opts' => {
            'project'=>'project|p=s',
            'branch'=>'branch|b=s',
            'install'=>'install|i',
            'type'=>'type|t=s',
            'dist'=>'dist!'            
        }        
    }
	
};


# if we self-install, we don't need
# dist or config, mostly because it doesn't 
# really exist
unless ( $act eq 'self-install' ) {
	
	# set some thigns
	use constant CONFIG => new drib::db('config',VAR);	
	use constant DIST => new drib::dist::remote(CONFIG);
	use constant PACKAGES => new drib::db('packges',VAR);
    	
    # if not running as root
    if ( $> != 0 ) {
        my $cmd = "sudo $0 ".join(" ",@ARGV); print `$cmd`; exit;
    }	
	
}

# cmds 
my @cmds = @ARGV; shift @cmds;

# is the given command correct
unless ( exists $Commands->{$act} ) {
    $act = 'help';
}

# get options
my %options = ();

    # opts
    my $opts = $Commands->{$act}->{opts};
    
    # get options
    GetOptions(\%options, values %{$opts});    

# call it 
$Commands->{$act}->{func}();

# done
exit 1;

# help
sub help {

    # check if we want to show the version
    if ( $options{'version'} ) {
    
        # fail with version
        fail("drib $VERSION\nCopyright (C) Travis Kuhl 2009-10\n\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\nThere is NO WARRANTY, to the extent permitted by law.");
    
    }
    else {
    
        # usage
        msg("usage: drib [options] command [sub-command] [command-options]\n\nList of Commands:");
        
        # show them commands
        foreach my $key ( keys %{$Commands} ) {
            printf(" %-20s %s\n", "$key","$Commands->{$key}->{help}");
        }
        
        # nothing more to do
        exit;
        
    }

}

# self_install
sub self_install {

	# what we need
	my ($conf,$var);

    # if not running as root
    if ( $> != 0 ) {
        fail("You must install as root.");
    }	
    
    # shift off install
    shift @ARGV;

	# ask
	my @Ask = (
	    ['username',"What is your drib.it Username",""],
		['key', "What is your drib.it API Key",""],
		['secret',"What is your drib.it API Secret",""],
		['project',"What would you like your default project to be?","default"],
		['binf',"Bin directory","/usr/local/bin"],
		['libf',"Lib directory","/usr/local/lib"],
		['varf',"Var directory","/usr/local/var"],
		['tmpf',"Tmp directory","/tmp"]
	);

	# ask them some questions
	foreach my $a ( @Ask ) {
		
		# back to an array
		@v = @{$a};
		
		if ( $#v == 2 ) {
			print $v[1]." [".$v[2]."]: "; 
		}
		else {
			print $v[1].": ";
		}
		$var = <>;
		chomp $var;
		if ( $var eq "" ) {
			$var = $v[2];
		}
		$conf->{$v[0]} = $var;
	}  	
	
	# need them
    if ( $conf->{'username'} eq "" || $conf->{'key'} eq "" || $conf->{'secret'} eq "" ) {
        fail("You didn't enter a Username, API Key or Secret. You need to do that before we can install.");
	}
	
    # personalize the package file
    my $pkgfile = file_get("../pkg/drib.pkg");	

	# replace our lib 
	$pkgfile =~ s/\$bin = ""/\$bin = "$conf->{'binf'}"/;
	$pkgfile =~ s/\$lib = ""/\$lib = "$conf->{'libf'}"/;
	$pkgfile =~ s/\$var = ""/\$var = "$conf->{'varf'}"/;
	$pkgfile =~ s/\$tmp = ""/\$tmp = "$conf->{'tmpf'}"/;		

    # now rewrite package
    file_put("../pkg/drib.pkg.tmp",$pkgfile);

    # open our file
    my $file = file_get("./drib");
    
	# replace our lib 
	$file =~ s/VAR =\> "\.\/"/VAR => "$conf->{'varf'}\/drib"/;
	$file =~ s/LIB =\> "\.\/lib"/LIB => "$conf->{'libf'}\/drib"/;

	# put the content back
	file_put("./drib",$file);	

    # files
    $conf->{'libf'} .= "/drib";
    $conf->{'varf'} .= "/drib";
    $conf->{'tmpf'} .= "/drib";

	# need var dir now
	mkdir $conf->{'varf'};

	# save our json conf
	my $json = to_json($conf);
	
	# create our conf file
	file_put($conf->{'varf'}."/config.json",$json);

    # where are we 
    my $pwd = getcwd();

    # now build and 
    print `sudo ./drib create $pwd/../pkg/drib.pkg.tmp --install --no-dist`;

    # remove 
    `rm ../pkg/drib.pkg.tmp`;
    
}


# install
sub install {
	
	# given a file
	my ($pkg_file) = @_;
	
	# get commands
	my ($pkg,$version,$file,$project);

	# need a package name
	if ( $#cmds == -1 && !$pkg_file ) { fail("No Package Given"); }
	
	# if package has .tar.gz
	# we don't need to go to dist
	if ( $pkg_file || $cmds[0] =~ /\.tar\.gz/ ) {
     
        # not given
        if ( !$pkg_file ) {
            $pkg_file = $cmds[0];
        }
        
        # where
        unless ( -e "./$pkg_file" ) {
            fail("Package file $pkg_file does not exists");
        }
     
        # get it 
        $file = file_get($pkg_file);	
        
	}
	else {
	
        # try to split the package for a version
        my @pkg_info = split(/-/,$cmds[0]);
        
        # pkg
        $pkg = $pkg_info[0];	
    
    	# ver
    	my $ver = $options{'version'};
    	my $branch = $options{'branch'} || 'current';
    	my $project = $options{'project'} || CONFIG->get('project');
    		
    	# if they gave a verions
    	if ( $#pkg_info == 2 ) {
    		$version = $pkg_info[1];
    	}
    	elsif ( $ver ) { 
    		$version = $ver;
    	}
    	else {
    		$version = $branch;
    	}	
    
    	# check if the package ist installed
    	my $installed = PACKAGES->get($project,$pkg);
    
    		# if yes is it the same version
    		if ( $installed ne 0 ) {
    			fail("$pkg-$version is already installed");
    		}
    
    	# now we need to check with dist 
    	# to see if this package exists 
    	my $exists = DIST->check($project,$pkg,$version);
    
    	# if it exists we need to error
    	if ( !$exists ) {
    		fail("Package $pkg-$version does not exist.");
    	}
    
    	# ok so we now have it 
    	# so lets get the file
    	$file = DIST->get($pkg,$version);
    	
    }

	# make a tmp dir
	my $tdir = CONFIG->get('tmpf') . "/" . rand_str(10);
	
	# make it 
	`mkdir $tdir`;
	
	# save the file to tdir 
	file_put($tdir."/pkg",$file);
	
	# now move into the tmp dir 
	chdir $tdir;
	
	# untar the file
	`tar -xzf pkg`;
	
	# open our manifest
	my $manifest = from_json( file_get($tdir.'/.manifest') );
	
	# now lets get a list of all directories
	# and move them into place
	opendir(my $dh, '.');
	my @dirs = readdir($dh);
	close($dh);
	
	# loop and move each of the 
	# files to root. we force the 
	# move. so if any existing folders 
	foreach my $d ( @dirs ) {
		if ( $d ne '.' && $d ne '..' && -d $d ) {
			`cp -rf ./$d /`;
		}
	}
	
	# lines
	my @envs = ();
	
	# now loop through any env vars 
	# and write to the drib file
	if ( defined $manifest->{env} ) {
		foreach my $env ( keys %{$manifest->{env}} ) {
			push @envs, ($pkg."__".$env,$manifest->{env}{$env});
		}
	}
    
    # cleanup our tmp dir
    `rm -r $tdir`;    
	
	# tell them we're done
	fail("Package $manifest->{meta}->{name} installed!");
	
}

sub create {

	# get comd
	if ( $#cmds == -1 ) { fail("No Build Manifest given"); }
	
	# optns
	my $dist = $options{'dist'};
	my $branch = $options{'branch'} || 'current';
	my $type = $options{'type'} || 'release';
	my $install = $options{'install'} || 0;

        # not defined
        unless ( defined $options{'dist'} ) {
            $dist = 1;
        }

	# manifest file
	my $file = $cmds[0];
	
	# make sure we're in the correct folder
    my ($fname,$fpath) = fileparse($file);	
	
	# where are we now
	my $pwd = getcwd();    
    
    # move into fpath
    chdir $fpath;

	# open the manifest
	my $man = file_get($file);

	# check if the first two chars are 
	# a hash bang
	if ( substr($man,0,2) eq "#!" ) {
		$man = `$file`;
	}

	# save the man as a tmp file
	my $tmp = CONFIG->get('tmpf') . "/" . int(rand(20));

	# put the man
	file_put($tmp,$man);
	
	# what we need 
	our $Meta = 0;
	our $Set = 0;
	our $Dirs = 0;
	our $Files = 0;
	our $Commands = 0;
	our $Apache = 0;
	
	# try to include the file
	eval {
		do "$tmp";
	};
	
	# don't need the file anymore
	unlink $tmp;
	
	# if we couldn't we need to fail
	if ($@) {
		fail("Could not parse the Build Manifest");
	}
		
	# make sure we have what we need
 	if ( $Meta == 0) {
 		fail("Meta variable not defined in Build Manifest");
 	}

	# we need the package name
	my $pkg = $Meta->{name};
	my $version = $Meta->{version};
	my $project = CONFIG->get('project');
	
	   # is project defined in meta
	   if ( exists $Meta->{project} ) {
	       $project = $Meta->{project};
	   }

	
    # version
    if ( $type eq "symlink" || $type eq "s" ) {
        $version = "$version.S".time();
    }
    elsif ( $type eq "test" || $type eq "t" ) {
        $version = "$version.T".time();
    }

	# unless config tells us no dist we want
	# to make sure this version doesn't already 
	# exist
	if ( $dist == 1 ) {
		if ( DIST->check($project,$pkg,$version) ) {
			fail("Package '$pkg' version '$version' already exists");
		}
	}

	# need the changelog
	unless ( -e $Meta->{changelog} ) {
		fail("Changelog file ($Meta->{changelog}) does not exist.");
	}

	# now we need to create a tmp director
	my $tdir_name = rand_str(10);
	my $tdir = CONFIG->get('tmpf') . "/" . $tdir_name;

	# create the dir
	`mkdir $tdir`;

	# now create and dirs they want
	if ( $Dirs != 0 ) {
		foreach my $dir ( @{$Dirs} ) {
			my $d = $tdir . "/" . trim($dir);
			`sudo mkdir -p $d`;
		}
	}
	
	# no files
	if ( $Files != 0 ) {
		foreach my $f ( @{$Files} ) {
			
			# where are we going
			my $d = $tdir . trim($f->[0]);
			
			# if the dest doesn't exist 
			# we need to create it 
			unless ( -e $d ) {				
				`sudo mkdir -p $d`;			
			}
			
			# all the files
			my @files = ();
			
			# now figure out if src is a
			# single file or a ref
			unless ( ref($f->[1]) eq "HASH" ) {
				$f->[1] = {'src'=>$f->[1]};
			}
			
			# files
			my $file = $f->[1];
			
			# check if we have one file or many
			if ( defined $file->{src} ) {
				
				# add it
				push(@files,$file);
								
			}
			else {
			
				# check for lfind
				if ( defined $file->{find} ) {
					
					# run the find
					my $r = `sudo find $file->{find}`;
					my $root = "";
					
					# root 
					if ( defined $file->{root} ) {
					   $root = trim($file->{root});
					}
										
					# each file
					foreach my $item ( split(/\n/,$r) ) {
					   
                        # parse the file path
                        my ($fname,$fpath) = fileparse($item);
                        
                        # append
                        $append = "";
                        
                        # if path does not eq root
                        # we need to append the subdir to the 
                        # final dest also
                        if ( $root ne "" && trim($fpath) ne $root ) {
                            $fpath =~ s/$root//;
                            $append = $fpath;
                        }
					
                        # push ontop
						push(@files,{'src'=>$item,'user'=>$file->{user},'group'=>$file->{group},'mode'=>$file->{mode},'append'=>$append});
						
					}
					
				}					
			
			}
			
			
			# loop through each file
			foreach my $item ( @files ) {
		
				# filename
				my $n = basename($item->{src});
		
				# dest
				my $_d = "$d/$n";
				
				# check for append
				if ( defined $item->{append} && $item->{append} ne "" ) {
				
				    # append
				    $_d = "$d$item->{append}";
				    
				    # directory may not exist. we need to create it
				    unless ( -d $_d ) {
				        `mkdir -p $_d`;
				    }
				    
				    # append name
				    $_d .= $n;
				    
				}
	
                # now see what type of build we have
                if ( $type eq 'symlink' || $type eq 's' ) {
                    my $_s = $pwd . "/" . $item->{src};
                    symlink $_s, $_d;
                }
                else {	
    				`cp $item->{src} $_d`;
                }
			
				# if user
				if ( defined $item->{user} ) {
					`chown $item->{user} $_d`;
				}
				
				# group
				if ( defined $item->{group} ) {
					`chown :$item->{group} $_d`;
				}
				
				# mode
				if ( defined $item->{mode} ) {
					`chmod $item->{mode} $_d`;
				}				
		
		        # rename
		        if ( defined $item->{rename} ) {
                    `mv $_d $d/$item->{rename}`;
		        }
		  
			}
							
		}
	} # END @files
	
	# remove comments and extra linebreaks form man
	$man =~ s/#([^\n]+)\n//;
	$man =~ s/\n\n//;
	
	# need to create our own version of the manifest
	my $manifest = {
	    'project' => $project,
		'type' => $type,	
		'meta' => $Meta,
		'set' => $Set,
		'commands' => $Commands,
		'apache' => $Apache,
		'raw' => $man,
		'changelog' => file_get($Meta->{changelog}),
		'buildenv' => {
			'user' => $ENV{'USER'},
			'host' => $ENV{'HOSTNAME'},
			'pwd' => $ENV{'PWD'}			
		}
	};
	
	# add our manifest to the build 
	file_put($tdir."/.manifest", to_json($manifest) );

	# move to our folder
	chdir $tdir;
	
	# name 
	my $name = "$pkg-$version";

	# tar 
	`tar -czf $name.tar.gz .`;
	
	# package
	my $package = "$tdir/$pkg-$version.tar.gz";

	# now send our file to dist
	if ( $type eq 'release' && $dist == 1 ) {
    	DIST->upload({
    	   'project' => $project,
    	   'username' => CONFIG->get('username'),
    	   'name' => $pkg,
    	   'version' => $version,
    	   'branch' => $branch,
    	   'tar' => file_get($package)
        });
    }
    
    # or move the file back to the pwd 
    else {
    
        # put package in this directory
        `mv $package $pwd`;
    
    }
    
    # move back to current
    chdir $pwd;

	# remove our tmp dir
	`rm -r $tdir`;

    # install
    if ( $install ) {
    
        # msg
        msg("Package Created: $name");
     
        # run install
        &install($name.".tar.gz");
        
    }
    else {

    	# done
    	fail("Package Created: $name");
    	
    }

}

