#!/usr/bin/perl
#
#  drib
# =================================
#  (c) Copyright Travis Kuhl 2009-10
#  
#
# This is free software. You may redistribute copies of it under the terms of
# the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
# There is NO WARRANTY, to the extent permitted by law.
#

# our package
package Drib;

# version
our $VERSION = "1.0";


# use packages
use Getopt::Lucid qw( :all );
use Data::Dumper;
use File::Basename;
use File::Find;
use File::Spec;
use POSIX;
use Digest::MD5 qw(md5_hex);
use Crypt::CBC;
use JSON;

# lib
use lib "../lib";

# drib packages
use Drib::Utils;
use Drib::External;
use Drib::Db;
use Drib::Host;

# make me a drib
our $Drib = new Drib();

##
## @brief create a new instance
##
sub new {

	# get 
	my($ref) = @_;

	# get myself
	my $self = {
		'modules'	=> {},			# refs to modules
		'commands'	=> {},			# list of modules and their options
		'parsers'	=> {},			# list of available package file parsers
		'packages' 	=> {},			# ref to packages db
		'tmp'		=> "",			# our tmp director
		'var'		=> ""			# var folder
	};
	
	# bless and return me
	bless($self);	
	
	# var direcotry
	$self->{var} = File::Spec->rel2abs("../test/var/");
	
	# load our dbs
	$self->{packages}   = new Drib::Db('packges',$self->{var});
	
	# tmp 
	$self->{tmp} = "/tmp/drib/".rand_str(6);
	
		# create our tmp director
		mkdir($self->{tmp});	
		
	# load our modules
	$self->loadModules();
	
	# load our paresers 
	$self->loadParsers();
	
	# exec
	$self->run();
		
	# self
 	return $self;

}


##
## @brief run the routing and execute the 
##			proper functions
##
sub run {

	# who am i
	my $self = shift;
	
	# save a copy of the argv before we change it
	$self->{argv} = [@ARGV];
	
	# get cmd
	my $cmd = shift(@ARGV);	
	
	# see the cmd exists
	if ( exists $self->{commands}->{$cmd} ) {
		
		# c 
		my $c = $self->{commands}->{$cmd};
		
		# options
		my $o = $opt = Getopt::Lucid->getopt( \@{$c->{options}} );	
		
		# run it
		my $resp = $self->{modules}->{$c->{module}}->run($c->{name}, {$o->options}, @ARGV);
		
		# print the message
		msg($resp->{message},$resp->{code});
		
	}
	else {

		# help
		$self->help();
	
	}

}


##
## @brief help messaging
##
sub help {

msg("drib $VERSION\nCopyright (C) Travis Kuhl 2009-10\n\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\nThere is NO WARRANTY, to the extent permitted by law.");

}


##
## @brief cleanup stuff when we end
##
sub DESTROY {
	
	# who am i
	my $self = shift;
	
	# remove our tmp director
#	`rm -rf $self->{tmp}`;
	
}

##
## @brief load all available modules
##
sub loadModules {

	# who am i
	my $self = shift;

	# open the cmds directory and 
	# start loading me some commands
	my %modules = (
		'Create'	=> "Drib::Cmd::Create",
#		'Build'		=> "Drib::Cmd::Build",
		'Config'	=> "Drib::Cmd::Config",
		'Dist'		=> "Drib::Cmd::Dist",
		'Install'	=> "Drib::Cmd::Install",
		'Setting'	=> "Drib::Cmd::Setting",
		'Cron'		=> "Drib::Cmd::Cron",
		'Command'	=> "Drib::Cmd::Command",
	);
	
	
	# loop through and get each ones configs
	foreach my $mod ( keys %modules ) {
		
		# include module
		$self->includeModule($modules{$mod});
	
		# new
		my $m = $modules{$mod}->new($self);
	
		# get their commands
		foreach my $cmd ( @{$m->{commands}} ) {
			
			# mod
			$cmd->{module} = $mod;
			
			# alias
			my @alias = @{$cmd->{alias}};
			
			# push name to aliast
			push(@alias,$cmd->{name});
			
			# set it 
			foreach my $a ( @alias ) {										
				$self->{commands}->{$a} = $cmd;
			}
			
			
		}
	
		# save the module
		$self->{modules}->{$mod} = $m;
	
	}

}

##
## @brief load a module file from a mod name
##
## @param $name module name
##
sub includeModule {

	# get
	my ($self, $name) = @_;

	# slashes
	$name =~ s/::/\//g; 
	
	# require
	require $name.".pm";

}

##
## @brief load all available parsers
##
sub loadParsers {

	# who am i
	my $self = shift;

	# out of the box parsers
	$self->{parsers} = {
		'dpf'	=> "Drib::Parsers::Text",	# drib package file
		'dppf'	=> "Drib::Parsers::Perl",	# drib perl package file
		'djpf'	=> "Drib::Parsers::Json",	# drib json package file
		'pkg'	=> "Drib::Parsers::Perl"		# for backwards compatability
	};
	
}

##
## @brief open given file and parse contents
##
## @param $self	ref to self
## @param $file file name to parse
##
sub parsePackageFile {
	
	# get self and package
	my ($self, $file_name, $file) = @_;
	
	# parser
	my @parts = split(/\./,$file_name);

	# get the exension
	my $ext = pop(@parts);

	# does this exist in the parsers array
	if ( exists $self->{parsers}->{$ext} ) {
	
		# parse
		my $parse = $self->{parsers}->{$ext};

		# file 
		my $pf = $parse;
		   $pf =~ s/\:\:/\//g;
		
		# require
		require $pf.".pm";
		
		# parse
		return $parse->parse( $file );
		
	}
	else {
		return 0;
	}

}


##
## @brief unpackage a tared package file
##
## @param $tar tared package file
##
sub unpackPackageFile {

	# get the tar
	my ($self, $tar) = @_;

	# make a tmp dir
	my $tdir = $self->{tmp} . "/" . rand_str(10);

	# make it 
	mkdir($tdir);

	# save the file to tdir 
	file_put($tdir."/pkg",$tar);

	# now move into the tmp dir 
	chdir $tdir;

	# untar the file
	`sudo tar -xzf pkg`;

	# remove pkg
	`rm pkg`;
	
	# check for manifest
	unless ( -e $tdir."/.manifest" ) {
		return {
			'code' => 404,
			"message" => "No manifest in package file"
		};
	}
	else {
		return {
			'code' => 200,
			'tmp' => "$tdir",
			'manifest' => from_json( file_get($tdir.'/.manifest') )
		};
	}
	
}

##
## @brief parse a given string for package name and
##			other info
##
## @param $name package name string
##
sub parsePackageName {

    # get the raw package name
    my ($self, $name) = @_;

    # first explode for version
    ($part,$version) = split(/-/,$name);

    # now explode for the project and name
    ($project,$pkg) = split(/\//,$part);

    # if no pkg, it must not have a project
    if ( !$pkg ) {
        $pkg = $project;
        $project = 'default';
    }
    
    # give back an object
    return { 
    	'full' => "$project/$pkg-$version", 
    	'name' => $pkg, 
    	'project' => $project, 
    	'version' => $version, 
    	'pid' => $self->getPid($project,$pkg) 
    };

}


##
## @brief create a package unque package id
##
## @param $project name of project
## @param $package name of package
##
sub getPid {

    # project
    my ($self, $project, $name) = @_;
    
    	# no project or name
    	unless ( $project ne "" && $name ne "" ) {
    		return 0;
    	}
    
    # give back the hash
    return  md5_hex($project."-".$name);

}